%! suppress = LineBreak
%! suppress = MissingLabel
%! suppress = FileNotFound
\documentclass[../main.tex]{subfiles}
\begin{document}
    \subsection{Testowanie}
    Testowanie oprogramowania to \textbf{wykonywanie kodu dla pewnych kombinacji} danych wejściowych i
    stanów w celu wykrycia błędów.

    \textbf{Udany test - wykrycie błędu.} Efektywność testu - zdolność do znajdywania błędów.

    Testowanie $+$ statyczna weryfikacja $=$ \textbf{pełne pokrycie dla weryfikacji i walidacji}.

    Testowanie jest \textbf{jedyną techniką walidacji dla wymagań niefunkcjonalnych}.

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ c p{8cm} }
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{testy.png}}
                &
                \textbf{Planowanie testów}
                \begin{itemize}
                    \item im wcześniej rozpoczniemy tym lepiej;
                    \item statyczna weryfikacja czy testowanie?
                    \item zasada Pareto;
                    \item definiowanie standardów dla testowania;
                \end{itemize}

                \textbf{Dokument planu testów}
                \begin{itemize}
                    \item Proces testowania
                    \item Śledzenie wymagań
                    \item Testowane elementy
                    \item Harmonogram testów
                    \item Procedury nagrywania testów
                    \item Wymagania odnośnie sprzętu i oprogramowania
                    \item Ograniczenia
                \end{itemize}

                \\
            \end{tabular}
        \end{center}
    \end{table}



    \textbf{Aksjomaty testowania}
    \begin{itemize}
        \item \textbf{Antyekstencjonalność} - zestaw testów pokrywających nadklasę może nie być odpowiedni
        dla jakiejś jej implementacji,
        \item \textbf{Antydekompozycja} - pokrycie testami modułu wołanego nie jest takie samo
        jak pokrycie tego, który woła,
        \item \textbf{Antykompozycja} - testy pokrywające segmenty modułu niekoniecznie są odpowiednie
        dla modułu jako całości.
    \end{itemize}


    \textbf{Pokrycie kodu}
    \begin{itemize}
        \item \textbf{Pokrycie instrukcji}: sprawdzana jest każda instrukcja,
        \item \textbf{Pokrycie gałęzi}: odwiedzamy każda gałąź; instrukcja warunkowa musi być raz spełniona a raz fałszywa.
    \end{itemize}

    \subsubsection{Rodzaje testów}
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{5cm} p{11cm} }
                \textbf{Jednostkowe}
                &
                \begin{itemize}
                    \item przeprowadzane na bardzo niskim poziomie aplikacji, bardzo zbliżonym
                    do kodu źródłowego oprogramowania,
                    \item polegają na testowaniu poszczególnych metod i funkcji
                    klas, komponentów lub modułów,
                    \item automatyzacja z reguły dość tania,
                    \item mogą one być bardzo szybko przeprowadzane przez serwer
                    ciągłej integracji.
                \end{itemize}
                \\

                \toprule

                \textbf{Integracyjne}
                &
                \begin{itemize}
                    \item sprawdzają, czy różne moduły lub usługi wykorzystywane przez oprogramowanie
                    dobrze ze sobą współpracują,
                    \item mogą być stosowane na przykład w celu sprawdzania
                    interakcji aplikacji z bazą danych lub upewnienia się, że mikro-usługi działają zgodnie z
                    postawionymi wymaganiami i oczekiwaniami,
                    \item droższe, ponieważ
                    wymagają uruchomienia wielu elementów aplikacji.
                \end{itemize}
                \\

                \toprule

                \textbf{Systemowe} - funkcjonalne i niefunkcjonalne
                &
                \begin{itemize}
                    \item sprawdzają funkcjonalne oraz niefunkcjonalne wymagania systemowe oraz jakość
                    testowanych danych,
                    \item technika czarnej skrzynki dla wymagań funkcjonalnych,
                \end{itemize}
                \\

                \toprule

                \textbf{Akceptacyjne}
                &
                \begin{itemize}
                    \item formalne testy sprawdzające spełnienie wymagań biznesowych,
                    \item wymagają uruchomienia i
                    poprawnego działania całości aplikacji i polegają na replikowaniu zachowań użytkowników,
                    \item mogą obejmować również np. wydajność systemu,
                    \item odrzucenie zmian w przypadku, gdy nie pozwalają one na
                    osiągnięcie postawionych celów i wymagań.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \textbf{Rodzaje testów w fazie pielęgnacji}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{3cm} p{13cm} }
                \textbf{Regresyjne}
                &
                \begin{itemize}
                    \item ponowne przetestowanie uprzednio testowanego programu po dokonaniu w nim modyfikacji
                    lub zmianie środowiska pracy
                    \item w celu upewnienia
                    się, że w wyniku zmian nie powstały nowe defekty lub nie ujawniły się wcześniej nie wykryte,
                \end{itemize}
                \\

                \toprule

                \textbf{Smoke test}
                &
                \begin{itemize}
                    \item przetestowanie sprzętu pod kątem tak oczywistego problemu, że wydobywający się z urządzenia dym
                    byłby przewidywanym kryterium niezaliczenia testu,
                    \begin{itemize}
                        \item \textbf{test pobieżny} (będzie to często test przeszukujący "wszerz", a nie "w głąb"; często będzie to test najbardziej typowej ścieżki czynności, którą może przebyć potencjalny użytkownik),
                        \item \textbf{test zajmujący} niewiele czasu (ma szybko udzielić informacji koniecznych do podjęcia decyzji, co zrobimy dalej w ramach testowania),
                        \item \textbf{test poszukujący} bardzo wyraźnych problemów (test zdany pomyślnie powinien wykluczyć zachodzenie ewidentnej awarii na swojej ścieżce),
                        \item \textbf{test dopuszczający} do kolejnego etapu prac (zwłaszcza w kontekście zaangażowania w tym kolejnym etapie znaczących zasobów).
                    \end{itemize}
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}



    \textbf{Techniki testowania}
    \begin{itemize}
        \item white box - struktura wewnętrzna
        \item black box - struktura zewnętrzna
    \end{itemize}

    \subsubsection{Automatyzacja testowania}
    \begin{itemize}
        \item \textbf{Bardzo istotny wybór wariantów testów}
        \item Automatyzacja testów znacznie różni się od testowania.
        \item Bywa bardzo kosztowna, droższa nawet od ręcznego wykonania testów.
    \end{itemize}

    \textbf{Obietnice automatyzacji testowania}
    \begin{itemize}
        \item Zwiększenie testowania (przypadki testowe uruchamiane w minutach)
        \item Zmniejszenie kosztu testowania aż do 80% wysiłku ręcznegotestowania
        \item Lepszej jakości oprogramowanie wyprodukowane szybciej
    \end{itemize}

    \textbf{Ocena jakości wariantu testu}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ c p{8cm} }
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{jakosc_testu.png}}
                &
                \textbf{Czynności w ramach testowania}
                \begin{itemize}
                    \item Identyfikacja warunków testu
                    \item Zaprojektowanie przypadków testowych
                    \item Zbudowanie przypadków testowych
                    \item Uruchomienie przypadków testowych
                    \item Porównanie uzyskanych wyników z oczekiwanymi
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \subsection{Kontrola jakości}


    \begin{itemize}
        \item \textbf{Jakość} - zgodność z wymaganiami,
        \item \textbf{Jakość projektu} - wamagania a projekt,
        \item \textbf{Jakość wykonania} - projekt a implementacja,
        \item \textbf{Cztery filary zapewniania jakości}
        \begin{itemize}
            \item zarządzanie konfiguracją
            \item testowanie
            \item przeglądy
            \item refaktoryzacja
        \end{itemize}
        \item \textbf{Anomalia} - sytuacja różna od oczekiwanej wynikającej ze specyfikacji, standardów lub
        czyjegoś doświadczenia,
        \item \textbf{Przegląd} - ocena artefaktu realizowana przez grupę osób
        \begin{itemize}
            \item Czy wszystkie stałe są zdefiniowane?
            \item Czy w trakcie manipulacji kolejką może wystąpić przerwanie? Jeśli tak, to czy kolejka jest
            ujęta w rejon krytyczny?
            \item Czy rejestry są odtwarzane przy wyjściu?
            \item Czy wszystkie liczniki są odpowiednio inicjowane (0 lub 1)?
            \item Czy są literały numeryczne, które powinny być zastąpione stałymi symbolicznymi?
            \item Czy wszystkie bloki na schemacie są potrzebne?
        \end{itemize}
    \end{itemize}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ c p{8cm} }
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{inspekcja.png}}
                &
                \begin{itemize}
                    \item \textbf{Inspekcja} - ocena artefaktu przeprowadzana przez współpracowników i kierowana przez moderatora
                    \begin{itemize}
                        \item omówienie (cały zespół)
                        \item przygotowaie (indywidualnie)
                        \item inspekcja (cały zespół) - akceptacja pełna lub warunkowa/powtórna inspekcja,
                        \item naprawa
                        \item sprawdzenie
                    \end{itemize}
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \textbf{Inspekcje Fagana}
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ c c }
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{fag_1.png}}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{fag_2.png}}
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \subsubsection{Refaktoryzacja}
    Refaktoryzacja - \textbf{zmiana wewnętrznej struktury programu}, która zwiększa jego \textbf{czytelności} i \textbf{obniża koszt
    pielęgnacji} bez zmiany jego obserwowalnego zachowania.

    \textbf{Motywacja}
    \begin{itemize}
        \item Wysoki koszt pielęgnacji oprogramowania
        \item Naturalny wzrost złożoności i entropii
        oprogramowania
        \item Prawa Lehmana: konieczna ciągła restrukturyzacja
    \end{itemize}

    \hfill \\

    \textbf{Predykat noSideEffectsP}\\
    Wejście:
    \begin{itemize}
        \item Program odwołujący się do zmiennej Var o wartości początkowej 1
        \item Funkcja F potencjalnie modyfikująca wartość Var
    \end{itemize}


    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{8cm} p{8cm} }
                \textbf{Problem 1}
                \begin{itemize}
                    \item Czy wywołanie funkcji F powoduje efekt uboczny w
                    postaci zmiany wartości zmiennej Var?
                \end{itemize}
                &
                \textbf{Lemat 1}
                \begin{itemize}
                    \item Problem 1 (braku efektów ubocznych) jest
                    nierozstrzygalny
                \end{itemize}
                \\

                \textbf{Problem 2}
                \begin{itemize}
                    \item Czy istnieje zbiór wejść, który powoduje zmianę
                    wartości zmiennej Var?
                \end{itemize}
                &
                \textbf{Lemat 2}
                \begin{itemize}
                    \item Problem 2 (zmodyfikowany braku efektów
                    ubocznych) jest NP-zupełny.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}


    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{8cm} p{8cm} }
                \textbf{Proste} & \textbf{Trudne} \\
                \toprule
                \begin{itemize}
                    \item zautomatyzowana weryfikacja,
                    \item weryfikowane poprzez statyczną analizę kodu
                    \item można dowieść ich poprawności
                    \item obecnie w wielu środowiskach IDEs
                \end{itemize}
                &
                \begin{itemize}
                    \item weryfikacja wymaga testowania
                    \item testy muszą zostać stworzone ręcznie
                    \item nie można dowieść ich poprawności analitycznie
                    \item wymagają testów jednostkowych
                \end{itemize}
            \end{tabular}
        \end{center}
    \end{table}


\end{document}